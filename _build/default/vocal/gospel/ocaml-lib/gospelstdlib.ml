let contents = "(**************************************************************************)\n(*                                                                        *)\n(*  GOSPEL -- A Specification Language for OCaml                          *)\n(*                                                                        *)\n(*  Copyright (c) 2018- The VOCaL Project                                 *)\n(*                                                                        *)\n(*  This software is free software, distributed under the MIT license     *)\n(*  (as described in file LICENSE enclosed).                              *)\n(**************************************************************************)\n\n(* This file contains the GOSPEL standard library.\n   It is automatically opened.\n\n   The following are built-in in GOSPEL:\n\n   type unit\n   type string\n   type float\n   type bool\n   type integer\n\n   type 'a option\n   function None: 'a option\n   function Some (x: 'a) : 'a option\n\n   type 'a list\n   function ([]): 'a list\n   function (::) (x: 'a) (l: 'a list) : 'a list\n\n   predicate (=) (x y: 'a)\n*)\n\n(** Arithmetic\n\n   The type [integer] is built-in. This is the type of arbitrary precision integers,\n   not to be confused with OCaml's type [int] (machine integers).\n\n   There is a coercion from type [int] to type [integer], so that GOSPEL specifications\n   can be written using type [integer] only, and yet use OCaml's variables of type [int].\n*)\n\n(*@ function (+)   (x y: integer) : integer *)\n(*@ function (-)   (x y: integer) : integer *)\n(*@ function ( * ) (x y: integer) : integer *)\n(*@ function (/)   (x y: integer) : integer *)\n(*@ function mod   (x y: integer) : integer *) (* TODO allow infix in the parser*)\n(*@ function (-_)  (x: integer) : integer *)\n(*@ predicate (>)  (x y: integer) *)\n(*@ predicate (>=) (x y: integer) *)\n(*@ predicate (<)  (x y: integer) *)\n(*@ predicate (<=) (x y: integer) *)\n\ntype int\n\n(*@ function integer_of_int (x: int) : integer\n    coercion *)\n\n(*@ function abs (x:integer) : integer = if x >= 0 then x else -x *)\n\n(*@ function min (x y : integer) : integer\n    = if x <= y then x else y *)\n\n(*@ function max (x y : integer) : integer\n    = if x <= y then y else x *)\n\n(*@ function succ (x: integer) : integer = x + 1 *)\n(*@ function pred (x: integer) : integer = x - 1 *)\n\n(*@ function max_int : integer *)\n(*@ function min_int : integer *)\n\n\n(** Tuples *)\n\n(*@ function fst (p: 'a * 'b) : 'a *)\n(*@ function snd (p: 'a * 'b) : 'b *)\n\n(** References *)\n\ntype 'a ref\n(*@ ephemeral *)\n(*@ mutable model contents: 'a *)\n\n(*@ function (!_) (r: 'a ref) : 'a = r.contents *)\n\n(** Sequences\n\n    They are used in the following to model lists and arrays, and possibly other\n    data structures (queues, etc.).\n*)\n\n(*@ type 'a seq *)\n\n(*@ function length (s: 'a seq): integer *)\n\n(*@ function ([_]) (s: 'a seq) (i:integer): 'a *)\n\n(*@ predicate (==) (s1 s2: 'a seq) =\n      length s1 = length s2 &&\n      forall i. 0 <= i < length s1 -> s1[i] = s2[i] *)\n\n(*@ function ([_.._]) (s: 'a seq) (i1: integer) (i2: integer): 'a seq *)\n(*@ function ([_..]) (s: 'a seq) (i: integer): 'a seq *)\n(*@ function ([.._]) (s: 'a seq) (i: integer): 'a seq *)\n\n(*@ function empty: 'a seq *)\n\n(*@ function (++) (s1: 'a seq) (s2: 'a seq): 'a seq *)\n\nmodule Seq : sig\n\n  (* re-export type t and functions length and [_], so that we can refer to them\n     using qualified identifiers (Seq.t, Seq.len, and Seq.get, respectively). *)\n  (*@ function len (s: 'a seq): integer = length s *)\n  (*@ function get (s: 'a seq) (i: integer) : 'a = s[i] *)\n\n  (*@ function create (x: integer) (f: integer -> 'a): 'a seq *)\n  (*@ axiom create_len : forall n, f. n >= 0 ->\n        length (create n f) = n *)\n  (*@ axiom create_def : forall n, f. n >= 0 ->\n        forall i. 0 <= i < n -> (create n f)[i] = f i *)\n\n  (* TODO : DO WE WANT SOMETHING LIKE THIS ? *)\n  (*@ function create (n: integer) (f: integer -> 'a) : 'a seq *)\n  (* @ requires 0 <= n\n      ensures  length result = n\n      ensures  forall i. 0 <= i < n -> result[i] = f i *)\n\n  (*@ function ([<-]) (s: 'a seq) (i: integer) (x: 'a): 'a seq *)\n\n  (*@ function cons (x: 'a) (s: 'a seq): 'a seq *)\n  (*@ function snoc (s: 'a seq) (x: 'a): 'a seq *)\n\n  (* FIXME singleton? *)\n\n  (*@ predicate mem (s: 'a seq) (x: 'a) =\n        exists i. 0 <= i < length s && s[i] = x *)\n\n  (*@ predicate distinct (s: 'a seq) =\n        forall i j. 0 <= i < length s -> 0 <= j < length s ->\n        i <> j -> s[i] <> s[j] *)\n\n  (*@ function rev (s: 'a seq) : 'a seq =\n        create (length s) (fun i -> s[length s - 1 - i]) *)\n\n  (*@ function map (f: 'a -> 'b) (s: 'a seq) : 'b seq =\n        create (length s) (fun i -> f s[i]) *)\n\n  (*@ function rec fold_left (f: 'a -> 'b -> 'a) (acc: 'a) (s: 'b seq) : 'a =\n        if length s = 0 then acc\n        else fold_left f (f acc s[0]) s[1 ..] *)\n\n  (*@ function rec fold_right (f: 'a -> 'b -> 'b) (s: 'a seq) (acc: 'b) : 'b =\n        if length s = 0 then acc\n        else f s[0] (fold_right f s[1 ..] acc) *)\n\n  (*@ function hd (s: 'a seq) : 'a = s[0] *)\n  (*@ function tl (s: 'a seq) : 'a seq = s[1 ..] *)\n\n  (* Sorted sequences of int values *)\n  (*@ predicate sorted_sub (s: int seq) (l u: integer) =\n        forall i1 i2. l <= i1 <= i2 < u -> s[i1] <= s[i2] *)\n  (*@ predicate sorted (s: int seq) =\n        sorted_sub s 0 (length s) *)\n\n  (* hd, tl, rev, mem *)\n  (* higher-order: map, fold, exists, forall, find, partition *)\n  (* assoc, mem_assoc? split, combine? *)\nend\n\nmodule SeqPerm : sig\n\n  (*@ function occ (s1: 'a seq) (v: 'a) (l u: integer) : integer *)\n\n  (*@ axiom occ_base: forall s1 v l u.\n        u <= l -> occ s1 v l u = 0 *)\n\n  (*@ axiom occ_ind: forall s1 v l u. 0 <= l <= v < u <= length s1 ->\n        occ s1 v l u = (if v = s1[l] then 1 else 0) + occ s1 v (l+1) u *)\n\n  (*@ predicate permut (s1 s2: 'a seq) (l u: integer) =\n        length s1 = length s2 &&\n        forall x. occ x s1 l u = occ x s2 l u *)\n\n  (*@ predicate permut_all (s1 s2: 'a seq) =\n        permut s1 s2 0 (length s1) *)\n\nend\n\n(** Lists\n\n     Type 'a list, [] and (::) constructors are built-in *)\n\n(*@ function seq_of_list (l: 'a list): 'a seq\n    coercion *)\n\n(** Arrays *)\n\ntype 'a array\n(*@ ephemeral *)\n(*@ mutable model contents: 'a seq *)\n(*@ model array_length: integer *)\n(*@ invariant array_length = length contents *)\n\n(*@ function elts (a: 'a array): 'a seq = a.contents\n    coercion *)\n\nmodule Array : sig\n\n  (* OCaml-like syntax a.(i) is mapped to Array.([_]) *)\n  (*@ function ([_]) (a: 'a array) (i: integer) : 'a = Seq.get a i *)\n\n  (*@ function length (a: 'a array) : integer = Seq.len a *)\n\nend\n\nmodule ArrayPermut : sig\n\n  (*@ predicate permut_sub (a b: 'a array) (i j: integer) *)\n  (*@ predicate permut_all (a b: 'a array) *)\n\nend\n\n(** Other OCaml built-in stuff *)\n\nexception Not_found\nexception Invalid_argument of string\n\nmodule Sys : sig\n\n  (*@ function word_size : integer *)\n\n  (*@ function int_size : integer *)\n\n  (*@ function big_endian : bool *)\n\n  (*@ function max_string_length : integer *)\n\n  (*@ function max_array_length : integer *)\n\nend\n\nmodule Order : sig\n\n  (*@ predicate is_pre_order (cmp: 'a -> 'a -> int) =\n      (forall x. cmp x x = 0) /\\\n      (forall x y. cmp x y <= 0 <-> cmp y x >= 0) /\\\n      (forall x y z.\n         (cmp x y <= 0 -> cmp y z <= 0 -> cmp x z <= 0) /\\\n         (cmp x y <= 0 -> cmp y z <  0 -> cmp x z <  0) /\\\n         (cmp x y <  0 -> cmp y z <= 0 -> cmp x z <  0) /\\\n         (cmp x y <  0 -> cmp y z <  0 -> cmp x z <  0)) *)\n\nend\n\nmodule Bag : sig\n\n  (*@ type 'a bag *)\n\n  (*@ function nb_occ (x: 'a) (b: 'a bag): integer *)\n\n  (*@ axiom occ_non_negative: forall b: 'a bag, x: 'a.\n        nb_occ x b >= 0 *)\n\n  (*@ predicate mem (x: 'a) (b: 'a bag) =\n        nb_occ x b > 0 *)\n\n  (*@ predicate eq_bag (a b: 'a bag) =\n        forall x:'a. nb_occ x a = nb_occ x b *)\n\n  (*@ axiom bag_extensionality: forall a b: 'a bag.\n        eq_bag a b -> a = b *)\n\n  (*@ function empty_bag: 'a bag *)\n\n  (*@ axiom occ_empty: forall x: 'a. nb_occ x empty_bag = 0 *)\n\n  (*@ function singleton (x: 'a) : 'a bag *)\n\n  (*@ axiom occ_singleton: forall x y: 'a.\n        nb_occ y (singleton x) = if x = y then 1 else 0 *)\n\n  (*@ function union (x:'a bag) (y:'a bag) : 'a bag *)\n\n  (* axiom occ_union: forall x: 'a, a b: 'a bag.\n      nb_occ x (union a b) = nb_occ x a + nb_occ x b *)\n\n    (** add operation *)\n\n  (*@ function add (x: 'a) (b: 'a bag) : 'a bag =\n        union (singleton x) b *)\n\n  (** cardinality of bags *)\n\n  (*@ function card (x:'a bag): integer *)\n\n  (*@ axiom card_nonneg: forall x: 'a bag.\n        card x >= 0 *)\n\n  (*@ axiom card_empty: card (empty_bag: 'a bag) = 0 *)\n\n  (*@ axiom card_zero_empty: forall x: 'a bag.\n        card x = 0 -> x = empty_bag *)\n\n  (*@ axiom card_singleton: forall x:'a.\n        card (singleton x) = 1 *)\n\n  (*@ axiom card_union: forall x y: 'a bag.\n        card (union x y) = card x + card y *)\n\n  (** bag difference *)\n\n  (*@ function diff (x: 'a bag) (y: 'a bag) : 'a bag *)\n\n  (*@ axiom diff_occ: forall b1 b2: 'a bag, x:'a.\n      nb_occ x (diff b1 b2) = max 0 (nb_occ x b1 - nb_occ x b2) *)\n\n  (** arbitrary element *)\n\n  (*@ function choose (b: 'a bag) : 'a *)\n\n  (*@ axiom choose_mem: forall b: 'a bag.\n        empty_bag <> b -> mem (choose b) b *)\n\nend\n\nmodule Set : sig\n\n  (*@ type 'a set *)\n\n  (*@ predicate mem (x: 'a) (s: 'a set) *)\n\n  (*@ function ( {} ) : 'a set *)\n\n  (*@ function ( {:_:} ) (x: 'a) : 'a set *)\n\n  (*@ function union (x:'a set) (y:'a set) : 'a set *)\n\n  (*@ function sum (f:'a -> integer) (x: 'a set) : integer *)\n\nend\n\nmodule Map : sig\n\n  (* the type ('a, 'b) map is defined internally in GOSPEL and can be\n     written as 'a -> 'b *)\n\n  (*@ function ( [<-] ) (m: 'a -> 'b) (x:'a) (y: 'b) : 'a -> 'b *)\n\n  (*@ function ( [_] ) (m: 'a -> 'b) (x: 'a) : 'b *)\n\nend\n\nmodule Peano : sig\n  type t\n  (*@ model v: integer *)\n\n  (*@ function int_of_peano (t: t) : integer = t.v\n      coercion *)\nend\n"
